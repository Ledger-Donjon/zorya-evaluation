  GNU nano 6.2                                                  ../tests/script.ini                                                            
# 1) import the initial state from the snapshot of a concrete run
# $ gdb --args ./broken-calculator-tinygo 00000000000 + 00000000000
# and set the entrypont to <main.main> 
starting from core


# 2) make symbolic the command line arguments
# here we reserved room for 11 characters integers
## <os.Args> is an array of strings
## Go string is a struct with 2 fields (data pointer and size)
@[@[@[<os.Args>, 8] + 0x10, 8], 11] := arg1[0, 11]
@[@[<os.Args>, 8] + 0x18, 8] := nondet as arg1_len
@[@[@[<os.Args>, 8] + 0x20, 8]] := arg2[0]
@[@[<os.Args>, 8] + 0x28, 8] := 1
@[@[@[<os.Args>, 8] + 0x30, 8], 11] := arg3[0, 11]
@[@[<os.Args>, 8] + 0x38, 8] := nondet as arg3_len
assume 1 <= arg1_len <= 11 && arg1[arg1_len] = 0
    && 1 <= arg3_len <= 11 && arg3[arg3_len] = 0

# 3) directives

## no specific goal
explore all

## cut exploration at <main.main> return site
halt at @[rsp, 8]

## raise error at *Panic functions
abort at <runtime.lookupPanic>
abort at <runtime.nilPanic>
abort at <runtime.divideByZeroPanic>

# 4) optimization : branchless stub for integer parsing
# replace <strconv.Atoi> (str, len) by
#  rax := 0
#  rdx := -1
#  for i<64> in 1 to 11 do
#    char<8> := 0
#    value<64> := 0
#    valid<1> := true
#    for j<64> in 0 to i - 1 do
#      char<8> := @[str + j]
#      value := 10 * value + uext64 ('0' <= char <= '9' ? char - '0' : 0)
#      valid := valid && ('0' <= char < '9' || j = 0 && (char = '+' | char = '-'))  
#    end
#    value := @[str] = '-' ? -value : value
#    rax := len = i ? value  : rax
#    rdx := len = i ? ~(sext64 valid) : rdx
#  end
#  return
# end